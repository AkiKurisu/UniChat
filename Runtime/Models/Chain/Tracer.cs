using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine;
namespace Kurisu.UniChat.Chains
{
    /// <summary>
    /// Run schema in the Tracer
    /// </summary>
    public class Run
    {      /// <summary>
           /// Unique identifier for the run.
           /// </summary>
        public string Id { get; set; } = string.Empty;

        /// <summary>
        /// Human-readable name for the run.
        /// </summary>
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Start time of the run.
        /// </summary>
        public DateTime StartTime { get; set; }

        /// <summary>
        /// The type of run, such as tool, chain, llm, retriever,
        /// embedding, prompt, parser.
        /// </summary>
        public string RunType { get; set; } = string.Empty;

        /// <summary>
        /// End time of the run, if applicable.
        /// </summary>
        public DateTime? EndTime { get; set; }

        /// <summary>
        /// Additional metadata or settings related to the run.
        /// </summary>
        public Dictionary<string, object> ExtraData { get; set; } = new();

        /// <summary>
        /// Error message, if the run encountered any issues.
        /// </summary>
        public string Error { get; set; } = string.Empty;

        /// <summary>
        /// Serialized object that executed the run for potential reuse.
        /// </summary>
        public Dictionary<string, object> Serialized { get; set; } = new();

        /// <summary>
        /// List of events associated with the run, like start and end events.
        /// </summary>
        public List<Dictionary<string, object>> Events { get; set; } = new();

        /// <summary>
        /// Inputs used for the run.
        /// </summary>
        public Dictionary<string, object> Inputs { get; set; } = new();

        /// <summary>
        /// Outputs generated by the run, if any.
        /// </summary>
        public Dictionary<string, object> Outputs { get; set; } = new();

        /// <summary>
        /// Reference to an example that this run may be based on.
        /// </summary>
        public Guid ReferenceExampleId { get; set; }

        /// <summary>
        /// Identifier for a parent run, if this run is a sub-run.
        /// </summary>
        public string ParentRunId { get; set; }

        /// <summary>
        /// Tags for categorizing or annotating the run.
        /// </summary>
        public List<string> Tags { get; set; } = new();
        /// <summary>
        /// The execution order of the run within a run trace.
        /// </summary>
        public int ExecutionOrder { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public int? ChildExecutionOrder { get; set; }

        /// <summary>
        /// The child runs of this run
        /// </summary>
        public List<Run> ChildRuns { get; set; } = new();

    }
    /// <summary>
    /// Base class for exceptions in tracers module.
    /// </summary>
    public class TracerException : Exception
    {
        public TracerException(string message) : base(message)
        {
        }

        public TracerException()
        {
        }

        public TracerException(string message, Exception innerException) : base(message, innerException)
        {
        }
    }
    /// <summary>
    /// Base class for tracers.
    /// </summary>
    public abstract class Tracer : CallbackHandler
    {
        /// <summary>
        /// Map contains all existed run
        /// </summary>
        protected static Dictionary<string, Run> RunMap { get; } = new();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask PersistRun(Run run);

        /// <inheritdoc />
        public override async UniTask HandleLlmStartAsync(ILargeLanguageModel llm,
            string[] prompts,
            string runId,
            string parentRunId = null,
            IReadOnlyList<string> tags = null,
            IReadOnlyDictionary<string, object> metadata = null,
            string name = null,
            IReadOnlyDictionary<string, object> extraParams = null)
        {
            var executionOrder = GetExecutionOrder(parentRunId);
            var startTime = DateTime.UtcNow;

            extraParams ??= new Dictionary<string, object>();
            var extraParamsCopy = new Dictionary<string, object>();
            extraParamsCopy.TryAddKeyValues(extraParams);
            if (metadata != null)
            {
                extraParamsCopy.Add("metadata", metadata);
            }

            var run = new Run
            {
                Id = runId,
                ParentRunId = parentRunId,
                //todo: pass llm or dumpd(llm)
                // serialized = serialized,
                Inputs = new Dictionary<string, object> { ["prompts"] = prompts },
                ExtraData = extraParamsCopy,
                Events = new List<Dictionary<string, object>>
                {
                    new()
                    {
                        ["name"] = "start",
                        ["time"] = startTime
                    }
                },
                StartTime = startTime,
                ExecutionOrder = executionOrder,
                ChildExecutionOrder = executionOrder,
                RunType = "llm",
                Tags = tags?.ToList() ?? new List<string>(),
                Name = name ?? string.Empty,
            };

            StartTrace(run);
            await HandleLlmStartAsync(run);
        }

        /// <inheritdoc/>
        public override async UniTask HandleLlmErrorAsync(Exception err, string runId, string parentRunId = null)
        {
            err = err ?? throw new ArgumentNullException(nameof(err));

            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_llm_error callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run) || run.RunType != "llm")
            {
                throw new TracerException($"No LLM Run found to be traced for {runId}");
            }

            run.Error = err.ToString();
            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { ["name"] = "error", ["time"] = run.EndTime });

            EndTrace(run);
            await HandleLlmErrorAsync(run);
        }

        /// <inheritdoc/>
        public override async UniTask HandleLlmEndAsync(ILLMResponse output, string runId, string parentRunId = null)
        {
            output = output ?? throw new ArgumentNullException(nameof(output));

            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_llm_end callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run) || run.RunType != "llm")
            {
                throw new TracerException($"No LLM Run found to be traced for {runId}");
            }

            run.Outputs = new();

            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { { "name", "end" }, { "time", run.EndTime } });

            EndTrace(run);
            await HandleLlmEndAsync(run);
        }

        public override async UniTask HandleLlmNewTokenAsync(string token, string runId, string parentRunId = null)
        {
            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_llm_new_token callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run) || run.RunType != "llm")
            {
                throw new TracerException($"No LLM Run found to be traced for {runId}");
            }

            var eventData = new Dictionary<string, object> { ["token"] = token };

            run.Events.Add(
                new()
                {
                    ["name"] = "new_token",
                    ["time"] = DateTime.UtcNow,
                    ["kwargs"] = eventData,
                });

            await HandleLlmNewTokenAsync(run, token);
        }

        public override UniTask HandleChatModelStartAsync(ILargeLanguageModel llm, IReadOnlyList<List<IMessage>> messages,
            string runId,
            string parentRunId = null,
            IReadOnlyDictionary<string, object> extraParams = null)
        {
            return UniTask.FromException(new NotImplementedException());
        }

        public override async UniTask HandleChainStartAsync(
            IChain chain,
            Dictionary<string, object> inputs,
            string runId,
            string parentRunId = null,
            List<string> tags = null,
            Dictionary<string, object> metadata = null,
            string runType = null,
            string name = null,
            Dictionary<string, object> extraParams = null)
        {
            var executionOrder = GetExecutionOrder(parentRunId);
            var startTime = DateTime.UtcNow;

            extraParams ??= new();
            if (metadata != null)
            {
                extraParams.Add("metadata", metadata);
            }

            var chainRun = new Run
            {
                Id = runId,
                ParentRunId = parentRunId,
                // serialized=serialized,
                Inputs = inputs,
                ExtraData = extraParams,
                Events = new List<Dictionary<string, object>> { new() { ["name"] = "start", ["time"] = startTime } },
                StartTime = startTime,
                ExecutionOrder = executionOrder,
                ChildExecutionOrder = executionOrder,
                ChildRuns = new(),
                RunType = runType ?? "chain",
                Name = name ?? string.Empty,
                Tags = tags ?? new()
            };

            StartTrace(chainRun);
            await HandleChainStartAsync(chainRun);
        }

        /// <summary>
        /// Handle an error for a chain run.
        /// </summary>
        public override async UniTask HandleChainErrorAsync(
            Exception err,
            string runId,
            Dictionary<string, object> inputs = null,
            string parentRunId = null)
        {
            err = err ?? throw new ArgumentNullException(nameof(err));

            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_chain_error callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run))
            {
                throw new TracerException($"No chain Run found to be traced for {runId}");
            }

            run.Error = err.ToString();
            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { ["name"] = "error", ["time"] = run.EndTime });

            run.Inputs = inputs ?? new();
            EndTrace(run);
            await HandleChainErrorAsync(run);
        }

        /// <summary>
        /// End a trace for a chain run.
        /// </summary>
        public override async UniTask HandleChainEndAsync(
            Dictionary<string, object> inputs,
            Dictionary<string, object> outputs,
            string runId,
            string parentRunId = null)
        {
            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_chain_end callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run))
            {
                throw new TracerException($"No chain Run found to be traced for {runId}");
            }

            run.Outputs = outputs;
            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { ["name"] = "end", ["time"] = run.EndTime });

            run.Inputs = inputs ?? new();

            EndTrace(run);
            await HandleChainEndAsync(run);
        }

        /// <inheritdoc/>
        public override async UniTask HandleToolStartAsync(
            Dictionary<string, object> tool,
            string input,
            string runId,
            string parentRunId = null,
            List<string> tags = null,
            Dictionary<string, object> metadata = null,
            string runType = null,
            string name = null,
            Dictionary<string, object> extraParams = null)
        {
            var executionOrder = GetExecutionOrder(parentRunId);
            var startTime = DateTime.UtcNow;

            extraParams ??= new Dictionary<string, object>();
            if (metadata != null)
            {
                extraParams.Add("metadata", metadata);
            }

            var run = new Run
            {
                Id = runId,
                ParentRunId = parentRunId,
                Serialized = tool,
                Inputs = new Dictionary<string, object> { ["input"] = input },
                ExtraData = extraParams,
                Events = new List<Dictionary<string, object>> { new() { ["name"] = "start", ["time"] = startTime } },
                StartTime = startTime,
                ExecutionOrder = executionOrder,
                ChildExecutionOrder = executionOrder,
                ChildRuns = new(),
                RunType = "tool",
                Tags = tags ?? new(),
                Name = name ?? string.Empty,
            };

            StartTrace(run);
            await HandleToolStartAsync(run);
        }

        /// <summary>
        /// Handle an error for a tool run.
        /// </summary>
        public override async UniTask HandleToolErrorAsync(Exception err, string runId, string parentRunId = null)
        {
            err = err ?? throw new ArgumentNullException(nameof(err));
            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_tool_error callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run) || run.RunType != "tool")
            {
                throw new TracerException($"No retriever Run found to be traced for {runId}");
            }

            run.Error = err.ToString();
            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { ["name"] = "error", ["time"] = run.EndTime });
            EndTrace(run);
            await HandleToolErrorAsync(run);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="output"></param>
        /// <param name="runId"></param>
        /// <param name="parentRunId"></param>
        /// <exception cref="TracerException"></exception>
        public override async UniTask HandleToolEndAsync(string output, string runId, string parentRunId = null)
        {
            if (runId == null)
            {
                throw new TracerException("No run_id provided for on_tool_end callback.");
            }

            if (!RunMap.TryGetValue(runId, out var run) || run.RunType != "tool")
            {
                throw new TracerException($"No retriever Run found to be traced for {runId}");
            }

            run.Outputs = new Dictionary<string, object>()
            {
                ["output"] = output
            };
            run.EndTime = DateTime.UtcNow;
            run.Events.Add(new Dictionary<string, object> { ["name"] = "end", ["time"] = run.EndTime });
            EndTrace(run);
            await HandleToolEndAsync(run);
        }

        public override UniTask HandleTextAsync(string text, string runId, string parentRunId = null)
        {
            return UniTask.CompletedTask;
        }

        public override UniTask HandleAgentActionAsync(Dictionary<string, object> action, string runId, string parentRunId = null)
        {
            return UniTask.CompletedTask;
        }

        public override UniTask HandleAgentEndAsync(Dictionary<string, object> action, string runId, string parentRunId = null)
        {
            return UniTask.CompletedTask;
        }

        /// <summary>
        /// Process a run upon creation.
        /// </summary>
        protected abstract void OnRunCreate(Run run);

        /// <summary>
        /// Process a run upon update.
        /// </summary>
        protected abstract void OnRunUpdate(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleLlmStartAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <param name="token"></param>
        /// <returns></returns>
        protected abstract UniTask HandleLlmNewTokenAsync(Run run, string token);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleLlmErrorAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleLlmEndAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleChatModelStartAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleChainStartAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleChainErrorAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleChainEndAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleToolStartAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleToolErrorAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleToolEndAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleTextAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleAgentActionAsync(Run run);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="run"></param>
        /// <returns></returns>
        protected abstract UniTask HandleAgentEndAsync(Run run);

        /// <summary>
        /// Add child run to a chain run or tool run.
        /// </summary>
        /// <param name="parentRun"></param>
        /// <param name="childRun"></param>
        private static void AddChildRun(Run parentRun, Run childRun) => parentRun.ChildRuns.Add(childRun);

        //Start a trace for a run.
        private void StartTrace(Run run)
        {
            if (run.ParentRunId != null)
            {
                if (RunMap.TryGetValue(run.ParentRunId, out var parentRun))
                {
                    AddChildRun(parentRun, run);

                    parentRun.ChildExecutionOrder =
                        Math.Max(parentRun.ChildExecutionOrder ?? 0, run.ChildExecutionOrder ?? 0);
                }
                else
                {
                    Debug.LogWarning($"Parent run with id {run.ParentRunId} not found.");
                }
            }
            RunMap[run.Id] = run;
            OnRunCreate(run);
        }

        //End a trace for a run.
        private void EndTrace(Run run)
        {
            if (run.ParentRunId == null)
            {
                PersistRun(run);
            }
            else
            {
                if (RunMap.TryGetValue(run.ParentRunId, out var parentRun))
                {
                    if (run.ChildExecutionOrder != null && parentRun.ChildExecutionOrder != null &&
                        run.ChildExecutionOrder > parentRun.ChildExecutionOrder)
                    {
                        parentRun.ChildExecutionOrder = run.ChildExecutionOrder;
                    }
                }
                else
                {
                    Debug.LogWarning($"Parent run with id {run.ParentRunId} not found.");
                }
            }
            RunMap.Remove(run.Id);
            OnRunUpdate(run);
        }

        //Get the execution order for a run.
        private int GetExecutionOrder(string parentRunId = null)
        {
            if (parentRunId == null)
            {
                return 1;
            }

            if (RunMap.TryGetValue(parentRunId, out var parentRun))
            {
                if (parentRun.ChildExecutionOrder == null)
                {
                    throw new TracerException($"Parent run with id {parentRunId} has no child execution order.");
                }
                return parentRun.ChildExecutionOrder.Value + 1;
            }
            else
            {
                Debug.LogWarning($"Parent run with id {parentRunId} not found.");
            }

            return 1;
        }
    }
}